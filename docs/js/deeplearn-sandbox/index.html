<html>
        <!-- <script src="https://storage.googleapis.com/learnjs-data/deeplearn-latest.js"></script> -->
        <!-- <script src="https://unpkg.com/deeplearn@0.3.3/dist/deeplearn.js"></script> -->
        <script src="lib/deeplearn.js"></script>
        <!-- <script src="lib/deeplearn.min.js"></script> -->
        <!-- <script src="sandbox.js"  type="module"></script> -->
        <script src="regression.js"></script>

      </style>
      
        <body>
          <p>Fitting a quadratic equation like <code>y = a * x^2 + b * x + c</code> through a set of points</p>
          <p>Press any key to begin computation</p>
          <canvas id="regression-canvas" height="600" width="800"></canvas>
          <p id='decription'></p>
        </body>
        
        <script src="Plot.js"></script>
        <script>
    (async () => {
const regressionCanvas = document.querySelector('#regression-canvas');
const description = document.querySelector('#decription');
const myGraph = new Plot({
    canvas: regressionCanvas,
    minX: -10,
    minY: -50,
    maxX: 10,
    maxY: 50,
    unitsPerTickX: 1,
    unitsPerTickY: 10
});
const sampleX = myGraph.samplePositions();

const drawPrediction = async () => {
  const predictions = await predict(sampleX);
  const zipped = sampleX.map((x, index) => [x, predictions[index]]);
  myGraph.drawPoints(zipped, 'green', 1);
};
await drawPrediction();

// myGraph.drawEquation(x => {
//   // y = b * x + c
//   const b = 5;
//   const c = 20;
//   const y = b * x + c;
//   return y;
// }, 'blue', 1);

const points = [
  [0, 1.1],
  [1, 5.9],
  [2, 16.8],
  [3, 33.9],
  [-1, 2],
  [-4, 45]
];

// const points = [
//   [0, -41.1],
//   [1, -5.9],
//   [2, -16.8],
//   [3, -33.9],
//   [-1, -30],
//   [-2, -10],
//   [-4, -45]

// ];
const drawScatter = () => myGraph.scatterPlot(points, 'red', 2);

drawScatter();

const timeout = millis => new Promise(resolve => setTimeout(() => resolve(), millis));

const keypress = () => new Promise(resolve => window.onkeypress = () => resolve());
await keypress();

const draw = async ({a, b, c, loss}) => {
  console.log(`a=${a}, b=${b}, c=${c}, loss=${loss}`);
  myGraph.clear();
  description.innerHTML = `a=${a}, b=${b}, c=${c}, loss=${loss}`;
  drawScatter();
  // drawPrediction();
  myGraph.drawEquation(x => a * x ** 2 + b * x + c, 'green', 1);
  return timeout(100);
};

const {a, b, c, loss} = await fitCurveThroughPoints(points, draw);

})();
        </script>

        <!-- <script>
{
// import {Array1D, NDArrayMathGPU, Scalar} from 'deeplearn';
const {Array1D, NDArrayMathGPU, Scalar} = deeplearn

const math = new NDArrayMathGPU()
const a = Array1D.new([1, 2, 3])
const b = Scalar.new(2)

math.enableDebugMode()

// cleans up GPU resources after use
math.scope(() => {
  const result = math.add(a, b)
  console.log(result.getValues())  // Float32Array([3, 4, 5])
})
}
        </script> -->

<!-- <script>
// https://pair-code.github.io/deeplearnjs/docs/tutorials/intro.html#training

const {Graph, Array2D} = deeplearn

const g = new Graph();

// Placeholders are input containers. This is the container for where we will
// feed an input NDArray when we execute the graph.
const inputShape = [3];
const inputTensor = g.placeholder('input', inputShape);

const labelShape = [1];
const labelTensor = g.placeholder('label', labelShape);

// Variables are containers that hold a value that can be updated from
// training.
// Here we initialize the multiplier variable randomly.
const multArray = Array2D.randNormal([1, 3])
console.log(`Initial values for multiplier: ${multArray.getValues()}`)
const multiplier = g.variable('multiplier', multArray);
console.log(multiplier.shape)

// Top level graph methods take Tensors and return Tensors.
const outputTensor = g.matmul(multiplier, inputTensor);
const costTensor = g.meanSquaredCost(outputTensor, labelTensor);

// Tensors, like NDArrays, have a shape attribute.
console.log(outputTensor.shape);

console.log('Training')

const {CostReduction, NDArrayMathGPU, Array1D, InCPUMemoryShuffledInputProviderBuilder, Session, SGDOptimizer} = deeplearn

const learningRate = .00001;
const batchSize = 3;
const math = new NDArrayMathGPU();

const session = new Session(g, math);
const optimizer = new SGDOptimizer(learningRate);

const inputs = [
  Array1D.new([1.0, 2.0, 3.0]),
  Array1D.new([10.0, 20.0, 30.0]),
  Array1D.new([100.0, 200.0, 300.0])
];

const labels = [
  Array1D.new([4.0]),
  Array1D.new([40.0]),
  Array1D.new([400.0])
];

// Shuffles inputs and labels and keeps them mutually in sync.
const shuffledInputProviderBuilder =
  new InCPUMemoryShuffledInputProviderBuilder([inputs, labels]);
const [inputProvider, labelProvider] =
  shuffledInputProviderBuilder.getInputProviders();

// Maps tensors to InputProviders.
const feedEntries = [
  {tensor: inputTensor, data: inputProvider},
  {tensor: labelTensor, data: labelProvider}
];

const NUM_BATCHES = 50;
for (let i = 0; i < NUM_BATCHES; i++) {
  // Wrap session.train in a scope so the cost gets cleaned up automatically.
  math.scope(() => {
    // Train takes a cost tensor to minimize. Trains one batch. Returns the
    // average cost as a Scalar.
    const cost = session.train(
        costTensor, feedEntries, batchSize, optimizer, CostReduction.MEAN);

    console.log('last average cost (' + i + '): ' + cost.get());
  });
}

console.log(`Values for multiplier after training: ${session.eval(multiplier).getValues()}`)

console.log('Prediction')

// Wrap session.eval in a scope so the intermediate values get cleaned up
// automatically.
math.scope((keep, track) => {
  const testInput = track(Array1D.new([0.1, 0.2, 0.3]));
  // const testInput = track(Array1D.new([1, 2, 3]));

  // session.eval can take NDArrays as input data.
  const testFeedEntries = [
    {tensor: inputTensor, data: testInput}
  ];

  const testOutput = session.eval(outputTensor, testFeedEntries);

  console.log('---inference output---');
  console.log('shape: ' + testOutput.shape);
  console.log('value: ' + testOutput.get(0));
});

// Cleanup training data.
inputs.forEach(input => input.dispose());
labels.forEach(label => label.dispose());
</script> -->
</html>