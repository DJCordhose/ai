<html>
        <!-- <script src="https://storage.googleapis.com/learnjs-data/deeplearn-latest.js"></script> -->
        <script src="lib/deeplearn-latest.js"></script>
        <!-- <script src="sandbox.js"  type="module"></script> -->

        <script>
{
// import {Array1D, NDArrayMathGPU, Scalar} from 'deeplearn';
const {Array1D, NDArrayMathGPU, Scalar} = deeplearn

const math = new NDArrayMathGPU()
const a = Array1D.new([1, 2, 3])
const b = Scalar.new(2)

// cleans up GPU resources after use
math.scope(() => {
  const result = math.add(a, b)
  console.log(result.getValues())  // Float32Array([3, 4, 5])
})
}
        </script>

<!-- <script>
// https://pair-code.github.io/deeplearnjs/docs/tutorials/intro.html#training

const {Graph, Array2D} = deeplearn

const g = new Graph();

// Placeholders are input containers. This is the container for where we will
// feed an input NDArray when we execute the graph.
const inputShape = [3];
const inputTensor = g.placeholder('input', inputShape);

const labelShape = [1];
const labelTensor = g.placeholder('label', labelShape);

// Variables are containers that hold a value that can be updated from
// training.
// Here we initialize the multiplier variable randomly.
const multArray = Array2D.randNormal([1, 3])
console.log(`Initial values for multiplier: ${multArray.getValues()}`)
const multiplier = g.variable('multiplier', multArray);
console.log(multiplier.shape)

// Top level graph methods take Tensors and return Tensors.
const outputTensor = g.matmul(multiplier, inputTensor);
const costTensor = g.meanSquaredCost(outputTensor, labelTensor);

// Tensors, like NDArrays, have a shape attribute.
console.log(outputTensor.shape);

console.log('Training')

const {CostReduction, NDArrayMathGPU, Array1D, InCPUMemoryShuffledInputProviderBuilder, Session, SGDOptimizer} = deeplearn

const learningRate = .00001;
const batchSize = 3;
const math = new NDArrayMathGPU();

const session = new Session(g, math);
const optimizer = new SGDOptimizer(learningRate);

const inputs = [
  Array1D.new([1.0, 2.0, 3.0]),
  Array1D.new([10.0, 20.0, 30.0]),
  Array1D.new([100.0, 200.0, 300.0])
];

const labels = [
  Array1D.new([4.0]),
  Array1D.new([40.0]),
  Array1D.new([400.0])
];

// Shuffles inputs and labels and keeps them mutually in sync.
const shuffledInputProviderBuilder =
  new InCPUMemoryShuffledInputProviderBuilder([inputs, labels]);
const [inputProvider, labelProvider] =
  shuffledInputProviderBuilder.getInputProviders();

// Maps tensors to InputProviders.
const feedEntries = [
  {tensor: inputTensor, data: inputProvider},
  {tensor: labelTensor, data: labelProvider}
];

const NUM_BATCHES = 50;
for (let i = 0; i < NUM_BATCHES; i++) {
  // Wrap session.train in a scope so the cost gets cleaned up automatically.
  math.scope(() => {
    // Train takes a cost tensor to minimize. Trains one batch. Returns the
    // average cost as a Scalar.
    const cost = session.train(
        costTensor, feedEntries, batchSize, optimizer, CostReduction.MEAN);

    console.log('last average cost (' + i + '): ' + cost.get());
  });
}

console.log(`Values for multiplier after training: ${session.eval(multiplier).getValues()}`)

console.log('Prediction')

// Wrap session.eval in a scope so the intermediate values get cleaned up
// automatically.
math.scope((keep, track) => {
  const testInput = track(Array1D.new([0.1, 0.2, 0.3]));
  // const testInput = track(Array1D.new([1, 2, 3]));

  // session.eval can take NDArrays as input data.
  const testFeedEntries = [
    {tensor: inputTensor, data: testInput}
  ];

  const testOutput = session.eval(outputTensor, testFeedEntries);

  console.log('---inference output---');
  console.log('shape: ' + testOutput.shape);
  console.log('value: ' + testOutput.get(0));
});

// Cleanup training data.
inputs.forEach(input => input.dispose());
labels.forEach(label => label.dispose());
</script> -->
</html>